/*
	Example: A tip calculation FIS (fuzzy inference system)
	Calculates tip based on 'servie' and 'food'

	If you want to about thIS example (and fuzzy logic), please 
	read Matlab's tutorial on fuzzy logic toolbox 
	http://www.mathworks.com/access/helpdesk/help/pdf_doc/fuzzy/fuzzy.pdf

									Pablo Cingolani 
									pcingola@users.sourceforge.net
*/

FUNCTION_BLOCK WallFollower	// Block definition (there may be more than one block per file)

VAR_INPUT				// Define input variables
	side_sensor : REAL; (* RANGE(0 .. 2) *)
	diag_sensor : REAL; (* RANGE(0 .. 2) *)
	right_front_sensor : REAL; (* RANGE(0 .. 2) *)
END_VAR

VAR_OUTPUT
  whell_linear_speed: REAL;
  whell_angular_speed: REAL;
END_VAR

FUZZIFY side_sensor
  RANGE := (0 .. 2);
  TERM very_close := (0.150, 0.270);
  TERM close := (0.250 , 0.350);
  TERM almost_close := (0.330 , 0.450);
  TERM in_range := (0.430 , 0.750);
  TERM far :=  (0.700 , 2.000);
END_FUZZIFY

FUZZIFY diag_sensor
  TERM very_close := (0.150, 0.270);
  TERM close := (0.250 , 0.350);
  TERM almost_close := (0.330 , 0.450);
  TERM in_range := (0.430 , 0.750);
  TERM far :=  (0.700 , 2.000);
END_FUZZIFY

FUZZIFY right_front_sensor
  TERM very_close := (0.150, 0.270);
  TERM close := (0.250 , 0.350);
  TERM almost_close := (0.330 , 0.450);
  TERM in_range := (0.430 , 0.750);
  TERM far :=  (0.700 , 2.000);
END_FUZZIFY


DEFUZZIFY whell_linear_speed
 
  TERM back := (-0.100 , -0.030);
  TERM stop := (-0.010 , 0.010);
  TERM slow := (0.030 , 0.090);
  TERM fast := (0.200 , 0.400);
  METHOD : COG;
  
  DEFAULT := 0;
END_DEFUZZIFY

DEFUZZIFY whell_angular_speed
  RANGE := (-0.900 .. 0.910);
  TERM verySharpRight := (-0.900, -0.450);
  TERM sharpRight :=  (-0.500 , -0.200);
  TERM right := (-0.300 , -0.010);
  TERM straight := (-0.010 , 0.100);
  TERM left := (0.000 , 0.300);
  TERM sharpLeft := (0.200, 0.500);
  TERM verySharpLeft := (0.450,  0.900);
  METHOD : COG;  
  DEFAULT := 0;
END_DEFUZZIFY



RULEBLOCK No1
	AND : MIN;			// Use 'min' for 'and' (also implicit use 'max' for 'or' to fulfill DeMorgan's Law)
	ACT : MIN;			// Use 'min' activation method
	ACCU : MAX;			// Use 'max' accumulation method

	
	
	RULE 1 : IF right_front_sensor IS in_range THEN whell_linear_speed IS slow;
  RULE 2 : IF right_front_sensor IS in_range THEN whell_angular_speed IS straight;
  RULE 3 : IF right_front_sensor  IS close THEN whell_linear_speed IS stop;
  RULE 4 : IF right_front_sensor  IS almost_close THEN whell_linear_speed IS stop;
  RULE 5 : IF right_front_sensor  IS close THEN whell_angular_speed IS verySharpLeft;
  RULE 6 : IF right_front_sensor  IS almost_close THEN whell_angular_speed IS verySharpLeft;
  RULE 7 : IF right_front_sensor IS very_close THEN whell_linear_speed IS back;
  RULE 8 : IF right_front_sensor IS very_close THEN whell_angular_speed IS verySharpLeft;
  RULE 9 : IF side_sensor  IS almost_close THEN whell_angular_speed IS right;
  RULE 10 : IF side_sensor  IS almost_close THEN whell_linear_speed IS slow;
  RULE 11 : IF side_sensor  IS close THEN whell_angular_speed IS straight;
  RULE 12 : IF side_sensor  IS close THEN whell_linear_speed IS fast;
  RULE 13 : IF side_sensor  IS very_close THEN whell_angular_speed IS left;
  RULE 14 : IF side_sensor  IS very_close THEN whell_linear_speed IS slow;
  RULE 15 : IF side_sensor  IS in_range THEN whell_angular_speed IS sharpRight;
  RULE 16 : IF side_sensor  IS very_close THEN whell_linear_speed IS fast;
  RULE 17 : IF side_sensor  IS far THEN whell_angular_speed IS verySharpRight;
  RULE 18 : IF side_sensor  IS far THEN whell_linear_speed IS stop;
  RULE 19 : IF right_front_sensor  IS far THEN whell_angular_speed IS verySharpRight;
  RULE 20 : IF right_front_sensor  IS far THEN whell_linear_speed IS stop;
  RULE 21 : IF diag_sensor  IS in_range THEN whell_angular_speed IS left;
END_RULEBLOCK

END_FUNCTION_BLOCK